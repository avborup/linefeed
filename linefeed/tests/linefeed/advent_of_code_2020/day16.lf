rules_str, own_str, nearby_str = input().split("\n\n");

rules = {};
for line in rules_str.lines() {
  name, min1, max1, min2, max2 = line.find(r/(.*?): (\d+)-(\d+) or (\d+)-(\d+)/n);
  rules[name] = ((min1..=max1), (min2..=max2));
};
own, nearby = own_str.nums(), [line.nums() for line in (nearby_str.lines())[1..]];

fn is_valid(n, rule) n in rule[0] or n in rule[1];

part1, valid = 0, [own];
for ticket in nearby {
  invalid_values = [n for n in ticket if not any([is_valid(n, r) for r in rules.values()])];
  match invalid_values {
    [] => valid.append(ticket),
    _ => part1 += sum(invalid_values),
  };
};

candidates, indices, taken = set(rules.keys()), {}, set();
for _ in 0..rules.len() {
  for name in candidates {
    possible_indices = [
      i for i in 0..own.len()
      if i not in taken and all([is_valid(t[i], rules[name]) for t in valid])
    ];

    break if possible_indices.len() == 1;
  };

  taken.add(possible_indices[0]);
  indices[name] = possible_indices[0];
  candidates.remove(name);
};

part2 = mul([own[i] for name, i in indices if name.starts_with("departure")]);

print("Part 1:", part1);
print("Part 2:", part2);
