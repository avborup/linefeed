rules_str, own_str, nearby_str = input().split("\n\n");

rules = {};
for line in rules_str.lines() {
  name, min1, max1, min2, max2 = line.find(r/(.*?): (\d+)-(\d+) or (\d+)-(\d+)/n);
  rules[name] = ((min1..=max1), (min2..=max2));
};
own = [m[0] for m in own_str.find_all(r/(\d+)/n)];
nearby = [[m[0] for m in line.find_all(r/(\d+)/n)] for line in (nearby_str.lines())[1..]];

fn is_valid(n, rule) n in rule[0] or n in rule[1];

part1, valid = 0, [own];
for ticket in nearby {
  invalid_values = [n for n in ticket if not any([is_valid(n, r) for r in rules.values()])];
  if invalid_values.len() > 0 {
    part1 += sum(invalid_values);
  } else {
    valid.append(ticket);
  };
};

candidates, indices, taken = set(rules.keys()), {}, set();
for _ in 0..rules.len() {
  for name in candidates {
    possible_indices = [
      i for i in 0..own.len()
      if i not in taken and all([is_valid(t[i], rules[name]) for t in valid])
    ];

    break if possible_indices.len() == 1;
  };

  taken.add(possible_indices[0]);
  indices[name] = possible_indices[0];
  candidates.remove(name);
};

part2 = mul([own[i] for name, i in indices if name.starts_with("departure")]);

print("Part 1:", part1);
print("Part 2:", part2);
