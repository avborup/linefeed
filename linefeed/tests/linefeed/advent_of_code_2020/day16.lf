rules_str, own_str, nearby_str = input().split("\n\n");

rules = {};
for line in rules_str.lines() {
  name, min1, max1, min2, max2 = line.find(r/(.*?): (\d+)-(\d+) or (\d+)-(\d+)/n);
  rules[name] = ((min1..=max1), (min2..=max2));
};
own = [m[0] for m in own_str.find_all(r/(\d+)/n)];
nearby = [[m[0] for m in line.find_all(r/(\d+)/n)] for line in (nearby_str.lines())[1..]];

fn is_valid(n, rule) n in rule[0] or n in rule[1];

part1, valid = 0, [own];
for ticket in nearby {
  invalid_values = [n for n in ticket if not any([is_valid(n, r) for r in rules.values()])];
  if invalid_values.len() > 0 {
    part1 += sum(invalid_values);
  } else {
    valid.append(ticket);
  };
};

candidates, indices, taken = set(rules.keys()), {}, set();
for _ in 0..rules.len() {
  found_name = null;
  found_index = null;
  for name in candidates {
    rule = rules[name];
    possible_indices = [
      i
      for i in 0..own.len()
      if i not in taken and all([is_valid(t[i], rule) for t in valid])
    ];

    if possible_indices.len() == 1 {
      found_name = name;
      found_index = possible_indices[0];
      break;
    };
  };

  taken.add(found_index);
  indices[found_name] = found_index;
  candidates.remove(found_name);
};

part2 = mul([
  own[indices[name]]
  for name in indices.keys()
  if name.starts_with("departure")
]);

print("Part 1:", part1);
print("Part 2:", part2);
