fn solve(seats, adj, threshold) {
  changed = true;
  while changed {
    changed = false;
    new_seats = {};

    for seat, kind in seats {
      num_occupied = 0;
      for neighbor in adj[seat] {
        if seats[neighbor] == "#" {
          num_occupied += 1;
        };
      };

      new_seats[seat] = kind;

      match kind {
        "L" => {
          if num_occupied == 0 {
            new_seats[seat] = "#";
            changed = true;
          };
        },
        "#" => {
          if num_occupied >= threshold {
            new_seats[seat] = "L";
            changed = true;
          };
        },
      };
    };

    seats = new_seats;
  };

  sum([1 for _, kind in seats if kind == "#"])
};

seats = {};
R, C = 0, 0;
for r, l in input().lines().enumerate() {
  for c, kind in list(l).enumerate() {
    seats[(r, c)] = kind if kind != ".";
    R, C = max(R, r + 1), max(C, c + 1);
  };
};

dirs = ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1));

adj, visible = defaultmap([]), defaultmap([]);
for seat, kind in seats {
  for dir in dirs {
    if seat + dir in seats {
      adj[seat].append(seat + dir);
    };

    pos = seat + dir;
    while pos[0] < R and pos[0] >= 0 and pos[1] < C and pos[1] >= 0 {
      if pos in seats {
        visible[seat].append(pos);
        break;
      };
      pos += dir;
    };
  };
};

part1 = solve(seats, adj, 4);
part2 = solve(seats, visible, 5);

print("Part 1:", part1);
print("Part 2:", part2);
